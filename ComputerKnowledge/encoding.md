# 编码

## ASCII

码表中只有英文大小写字母、数字、美式标点符号等

每个字符占用1个字节，所有字符映射的二进制都为正数，因此有128个字符映射关系

## GB2312

兼容 ASCII 码表，并加入了中文字符，码表中包含英文大小写字母、数字、美式标点符号占一个字节，中文占两个字节，中文映射的二进制都是负数，因此有 128× 128 = 16384 个字符映射关系

## GBK/GB18030：

兼容 GB2312 码表，英文大小写字母、数字、美式标点符号占一个字节，中文占两个字节，第一个字节为负数，第二个字节为正数和负数，因为有 128× 256 = 32768 个字符映射关系

## Unicode

Unicode 仅仅只是一个字符集，规定了符合对应的二进制代码，至于这个二进制代码如何存储则没有任何规定

Unicode 给每个字符提供了一个唯一的数字，唯一数字称为码点（code point），其范围介乎 `0x0` 至 `0x10FFFF` 之间

码点有多种编码方式，称为 Unicode 转换格式，包括：

- UTF-8：8 位可变长度编码。它把一个码点映射至 1 至 4 个字节

- UTF-16：16 位可变长度编码。它把一个码点映射至 1 至 2 个 16 位编码单元（即 2 至 4 个字节）

- UTF-32：32 位固定长度编码。它直接把码点映射至单个 32 位编码单元（即 4 字节）

### UTF-8

使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度，编码规则如下：

- 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题

- 对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充

UTF-8完全直接兼容ASCII码，而非不完全间接兼容

### UTF-16

Unicode 的字符不是一次性定义的，而是分区定义

目前，一共有 17 个平面，每个平面可以存放 65536 个字符

UTF-16 编码规则：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节

UTF-16 的编码长度要么是 2 个字节（`U+0000` 到 `U+FFFF`），要么是 4 个字节（`U+010000` 到 `U+10FFFF`）

ASCII 字符经过 UTF-16 编码后得到的两个字节，高字节始终是 `0x00`，很多 C 语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本

### UTF-32

UTF-32 每个码点固定使用四个字节表示，字节内容一一对应码点

## 字节序

字节序就是字节之间的顺序，当传输或者存储时，如果数字超过 1 个字节，需要指定字节间的顺序

字节序一般分为大端字节序或小端字节序

UCS 规范建议我们在传输字节流前，先传输字符 `ZERO WIDTH NO-BREAK SPACE`，接收者收到 FEFF，就表明这个字节流是 Big-Endian 的，如果收到 FFFE ，就表明这个字节流是 Little-Endian 的

字符 `ZERO WIDTH NO-BREAK SPACE` 就是 byte order mark，简称 BOM

字节序问题仅存在于某种编码下计算机一次读取字符大小大于一个字节的时候

因为 UTF-8 是单字节码元，所以是字节顺序无关的，它的字节顺序在所有系统中都是一样的，其码元序列与字节序列(字节流)相同，因此它实际上并不需要字节顺序标记 BOM

