# 高并发设计

## 指标

并发的指标一般有 QPS、TPS、IOPS、RT，都可归为系统吞吐率

- QPS：每秒查询率，对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准

- TPS：每秒传输的事物处理个数，即服务器每秒处理的事务数，包括一条消息入和一条消息出，加上一次用户数据库访问

- RT：响应时间，即发出请求到收到请求的时延

## 设计思路

### 垂直扩展

提升单机处理能力

- 硬件方向：更多核更高主频更大存储空间更多带宽

- 软件方向：合适的数据结构，改进架构，应用多线程、协程，以及上性能优化各种手段

### 水平扩展

分布式集群，一般会用到架构分层和服务拆分，通过分层做隔离，通过微服务解耦

## 关键技术

### 集群化的负载均衡

负载均衡就是把负载（request）均衡分配到不同的服务实例，利用集群的能力去对抗高并发

- DNS 负载均衡：客户端通过 URL 发起网络服务请求的时候，会去 DNS 服务器做域名解释，DNS 会按一定的策略（比如就近策略）把 URL 转换成 IP 地址，同一个 URL 会被解释成不同的 IP 地址，这便是 DNS 负载均衡；因为采用就近原则，所以能降低时延，但因为使用了 cache，会带来更新不及时的问题

- NGINX 负载均衡

### 数据库

数据库的单机 QPS 一般不高，也就几千，满足不了高并发的要求

#### 分库分表、读写分离

把一个库分成多个库，部署在多个数据库服务上，主库承载写请求，从库承载读请求；从库可以挂载多个，因为很多场景写的请求远少于读的请求，这样就把对单个库的压力降下来了

从库从主库同步更新数据，保持数据一致，主从同步

单个库太大，先看是因为表多导致数据多还是单张表里的数据多；表多而数据多，使用垂直切分，根据业务切分成不同的库；单张表的数据量太大，使用水平切分，即把表的数据按某种规则切分成多张表，甚至多个库上的多张表；分库分表的顺序应该是先垂直分，后水平分

- 垂直分库：针对一个系统中的不同业务进行拆分，将不同库分布到不同机器上

- 垂直分表：基于列字段大表拆小表，一般是表中的字段较多，将不常用的，数据较大，长度较长的拆分到扩展表

- 水平分表：针对数据量巨大的单张表，按照某种规则（RANGE，HASH）切分到多张表里面去，但是这些表还是在同一个库中，所以库级别的数据库操作还是有 IO 瓶颈

- 水平分库分表：将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同

事务支持：分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担

#### 缓存

一般系统的写入请求远少于读请求，针对写少读多的场景，适合引入缓存集群；在写数据库的时候同时写一份数据到缓存集群里，用缓存集群来承载大部分的读请求，因为缓存集群很容易做到高性能

问题：

- 一致性问题：更新 db 成功 + 更新 cache 失败导致不一致、 更新 db 失败 + 更新 cache 成功导致不一致、更新 db 成功 + 淘汰缓存失败导致不一致

- 缓存穿透：查询一定不存在的数据，会穿透缓存直接压到数据库，从而导致缓存失去作用；通过布隆过滤器或者查询不存在的 key时也把空结果写入缓存（设置较短的过期淘汰时间），从而降低命失

- 缓存雪崩：如果大量缓存在一个时刻同时失效，则请求会转到DB，则对DB形成压迫；为缓存失效时间添加随机值，降低同一时间点失效淘汰缓存数，避免集体失效事件发生

### 高写入的消息中间件

添加消息中间件 MQ 集群，做写请求异步化处理，实现削峰填谷的效果；消息队列能做解耦，在只需要最终一致性的场景下，很适合用来配合做流控

### 流控

流控解决流量短时间内集中爆发，有4种常见的流控算法：

- 计数器（固定窗口）：计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略；下一个周期开始时，进行清零，重新计数，实现简单

- 滑动窗口：将时间周期分为 N 个小周期，分别记录每个小周期内访问次数，并且根据时间滑动删除过期的小周期，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确

- 漏桶：访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略），漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空

- 令牌桶：程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略


## 微服务

随着业务规模的提高，逻辑层的复杂度也上升了，所以针对逻辑层的架构设计也出现很多新的技术和思路，常见的做法包括系统拆分，微服务

