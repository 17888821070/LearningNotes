# cpp 面试总结

## 浮点数比较

浮点数的存储并不总是精确的，例如在经过大量计算之后可能会将 3.14 保存为 3.1400000000001 或者 3.1439999999999，这时候如果直接用 `==` 来比较这两个数的话会输出错误的结果，`false`（C++ 中 `==` 只有在两个数字完全相同的情况下才判定为 `true`）。所以需要引入极小数 eps 来修正，只要不超出这个误差，那么就判定为 `true`

```cpp
const double eps = 1e-8;
#define Equ(a, b) ((fabs((a)-(b))<(eps))
```

## static

静态变量分全局静态变量和局部静态变量

在全局变量前加上关键字 `static`，全局变量就定义成一个全局静态变量，存储在静态存储区，在整个程序运行期间一直存在，全局静态变量在声明他的文件之外是不可见的

在局部变量之前加上关键字 `static`，局部变量就成为一个局部静态变量，存储在静态储存区，作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变

函数返回类型前加 `static`，函数就定义为静态函数，函数的定义和声明在默认情况下都是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员，对静态成员的引用不需要用对象名，在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员

## C++ 和 C 的区别

C++ 是面向对象的语言，而 C 是面向过程的结构化编程语言

C++ 具有封装、继承和多态三种特性，并且增加许多类型安全的功能，比如强制类型转换，支持范式编程，比如模板类、函数模板等

## C++ 中的强制转换

C++ 中四种类型转换是：`static_cast`, `dynamic_cast`,  `const_cast`, `reinterpret_cast`

`const_cast`: 将常量变量转换成非常量

`static_cast`: 
- 用于类层次结构中基类和派生类之间指针或引用的转换；上行转换（派生类---->基类）是安全的；下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的
- 用于基本数据类型之间的转换，如把 `int` 转换为 `char`，这种带来安全性问题由程序员来保证
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转为 `void` 类型

`dynamic_cast` 只能用于含有虚函数的类的转指针或引用，用于类层次间的向上和向下转化。向下转化时，如果是非法的对于指针返回 `NULL`，对于引用抛异常

`reinterpret_cast` 几乎什么都可以转，可移植性差

## 指针和引用

指针有自己的一块空间，而引用只是一个别名；使用 `sizeof` 看一个指针的大小是 4，而引用则是被引用对象的大小；指针可以被初始化为 `NULL`，而引用必须被初始化且必须是一个已有对象的引用；作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；可以有 `const` 指针，但是没有 `const` 引用；指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；指针可以有多级指针 `**p` ，而引用只有一级

从汇编层次来看，引用是通过指针来实现的，可以看作编译器自动完成取地址、解引用的常量指针，一旦编译成汇编就和指针一样，由于引用只是指针包装了下，所以也存在风险（引用指向的对象已经被释放），尽量用引用代替指针


## 四种智能指针

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间

`auto_ptr` 被 C++11 弃用，采用所有权模式，在拷贝、赋值过程中会剥夺所有权，一个指针变量指向的空间不能同时被两个 `auto_ptr` 所有，会被析构两次；不能管理数组，因为析构函数中用的是 `delete`

`unique_ptr` 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象，不允许构造、赋值，但可以移动构造和移动赋值

`shared_ptr` 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁时候释放，使用计数机制来表明资源被几个指针共享；可以指定删除器来实现析构数组；定义了互斥锁使得计数机制是线程安全的，但管理的资源不一定是线程安全的；循环引用会导致不释放资源

`weak_ptr` 是一种不控制对象生命周期的智能指针, 它指向一个  `shared_ptr` 管理的对象；进行该对象的内存管理的是那个强引用的 `shared_ptr`，`weak_ptr` 只是提供了对管理对象的一个访问手段；没有重载 `opreator*` 和 `->` 操作符，也就意味着即使分配到对象，他也没法使用该对象，使用 `lock()` 可以得到 `shared_ptr` 或直接转化为 `shared_ptr`

## 析构函数为什么必须是虚函数

将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们 `new` 一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏

C++ 默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存

类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数

## 构造函数不能是虚函数

从存储空间角度：虚函数对应一个 vtable，vtable 其实是存储在对象的内存空间的，如果构造函数是虚的，就需要通过 vtable 来调用，可是对象还没有实例化，也就是内存空间还没有，无法找到 vtable，所以构造函数不能是虚函数

从多态角度：虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数，而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，则构造函数为虚函数没有实际意义

## 内联函数、模板函数和虚函数

内联函数不能是虚函数，虚函数的机制是虚函数表，需要一个真正的函数地址，而内联函数展开后不是一个函数，只是一段简单的代码

类中的模板函数会根据具体的类型而实例化，这也就是说这个模板函数会实例多少个函数出来是不知道的，因此虚表的大小就不好确定了，所以虚函数不能是模板函数

函数模板内可以用非模板函数的虚成员函数，因为虚函数的个数确定

## 函数指针

函数指针是指向函数的指针变量，本身首先是一个指针变量，该指针变量指向一个具体的函数

## 静态函数和虚函数

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定，虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

static 成员不属于任何类对象或类实例，所以即使给此函数加上 virutal 也是没有任何意义的；同理，静态成员函数也不能被声明为 `const` 和 `volatile`

静态与非静态成员函数之间有一个主要的区别就是静态成员函数没有 `this` 指针，虚函数依靠 vptr 和 vtable 来处理，并且只能用 `this` 指针来访问它

## 重载和重写

重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中

重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

## strcpy 和 strlen

`strcpy` 是字符串拷贝函数，原型 `char* strcpy(char* dest, const char* src)`，从 src 逐字节拷贝到 dest，直到遇到 `'\0'` 结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是 `strncpy` 函数

`strlen` 函数是计算字符串长度的函数，返回从开始到 `'\0'` 之间的字符个数

## strcpy 和 memcpy 实现

### strcpy

`strcpy()` 需要判断：输入是否为空、source 到 dest 的复制、返回参数是 `char *` 类型

```cpp
/* Copy SRC to DEST.  */
char * strcpy(char * dst, const char * src) {
     if(!src || !des) return nullptr;
     char * tmp = dst;
     while(1) {
          *tmp = *src;
          if(*src != '\0') {
               ++src;
               ++tmp;
          }
          else break;
     }
     return des;
}
```
当 dst 指向的存储空间，不足以存储 src 指向的字符串，就会出现问题，会覆盖其他内存空间的值

对指针的判断只能做到判空，对于未初始化的指针是没有办法解决的

### memcpy

按字节一个一个拷贝

```cpp
void * memcpy(void* dst, void* src, int n) {
     if(!dst || !src) return nullptr;
     char * pt1 = (char*) dst, * pt2 = (char*) src;
     while(n--) {
          *pt1 = *pt2;
          ++pt1;
          ++pt2;
     }
     return dst;
}
```

有内存重叠的问题，需要分为 src 在前和 dst 在前分开考虑

## 虚函数和多态

多态主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定

在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率

为了支持多态类型，编译器还将类型信息的地址加入到虚表之中，为了避免对虚函数表里函数指针的影响，编译器把它放在虚函数表前面

## 隐式类型转换

对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换；对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象

## C++ 存储区

1. 栈：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等；栈顶的地址和栈的最大容量是系统预先规定好的，是向低地址扩展的连续内存区域；栈由系统自动分配，速度较快

2. 堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收；向高地址扩展的不连续内存区域；由 `new` 分配，一般速度比较慢，而且容易产生内存碎片

3. 全局（静态）区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放

4. 文字常量区：存放常量字符串，由系统释放

5. 程序代码区：存放函数体的二进制代码

## new/delete 和 malloc/free

`new/delete` 是 C++ 的关键字，而 `malloc/free` 是 C 语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

## RTTI

Runtime Type Information，运行时类型信息，提供了运行时确定对象类型的方法，在 C++ 层面主要体现在 `dynamic_cast` 和 `typeid`

- typeid 函数

对于内置数据类型，`typeid` 可以方便输出数据类型；对于自己创建的类对象，依然可以输出它们的数据类型

```cpp
class A
{
public:
     void Print() { cout<<"This is class A."<<endl; }
};

class B : public A
{
public:
     void Print() { cout<<"This is class B."<<endl; }
};

class C
{
public:
     virtual void Print() { cout<<"This is class C."<<endl; }
};

class D : public C
{
public:
     void Print() { cout<<"This is class D."<<endl; }
};

int main()
{
     A *pA = new B();
     cout<<typeid(pA).name()<<endl; // class A *
     cout<<typeid(*pA).name()<<endl; // class A

     C *pC = new D();
     cout<<typeid(pC).name()<<endl; // class C *
     cout<<typeid(*pC).name()<<endl; // class D
     return 0;
}
```

当类中不存在虚函数时，typeid 是编译时期的事情，也就是静态类型；当类中存在虚函数时，typeid 是运行时期的事情，也就是动态类型

一个类里面有 `virutal` 和没有 `virtual` 对于编译器来说，做的事完全不同的事情

- dynamic_cast

主要用于在多态的时候，它允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构中安全地转换类型，把基类指针（引用）转换为派生类指针（引用）

```cpp
class A {
public:
    virtual void fun();
}

class B : public A {
public:
    virtual void fun();
}

int main() {
    A* p1 = new A();
    A* p2 = new B();

    B* pt1 = static_cast<B*>(p2); 
    B* pt2 = dynamic_cast<B*>(p2); 
    // 因为 p2 指向派生类，所以使用 pt1、pt2 进行的操作都是安全的

    B* pt3 = static_cast<B*>(p1); // 成功，但使用 pt3 不安全
    B* pt4 = dynamic_cast<B*>(p1); // pt4 为空指针
    return 0;
}
```

## 虚函数表如何实现运行时多态

在内存布局头部存放指向虚函数表的指针，子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象

## 函数调用过程

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的 esp 指针压栈

## map、set

`map` 和 `set` 都是 C++ 的关联容器，其底层实现都是红黑树，几乎所有的 `map` 和 `set` 的操作行为都只是转调 RB-tree 的操作行为

`map` 中的元素是 key-value 对，关键字起到索引的作用，值则表示与索引相关联的数据；`set` 与之相对就是关键字的简单集合，`set` 中每个元素只包含一个关键字

`set` 的迭代器是 const 的，不允许修改元素的值；`map` 允许修改 value，但不允许修改 key

`map` 支持下标操作，`set` 不支持下标操作


## unordered_set、unordered_map

hash table 表格内的元素为 bucket，表格内的每个单元不只是个节点，甚至可能是一桶节点，以开链的方式解决哈希冲突

bucket 所维护的链表不是 STL 的 `list` 或 `slist`，而是自己维护，但 buckets 聚合体使用的是 `vector`，因此具备动态扩充能力

hash table 的迭代器没有后退操作

hash table 的 `vector` 以质数来设计大小

插入元素时，先判断是否需要重建表格，重建表格规则：拿所有元素个数（把新增元素进入后）与 `vector` 大小进行比较，如果前者大于后者则重建表格；对于每个 bucket 对应链表的元素，都重新计算哈希值，然后放进新桶里

基于上面的的扩容策略，对容器进行插入删除时迭代器不会失效

## STL 的 allocator

在C++中，其内存配置和释放如下：

`new` 运算分两个阶段：(1)调用 `::operator new` 配置内存;(2)调用对象构造函数构造对象内容

`delete` 运算分两个阶段：(1)调用对象希构函数；(2)掉员工`::operator delete` 释放内存

STL 的分配器用于封装 STL 容器在内存管理上的底层细节，将两个阶段操作区分开来：内存配置有 `alloc::allocate()` 负责，内存释放由 `alloc::deallocate()` 负责；对象构造由 `::construct()` 负责，对象析构由 `::destroy()` 负责

为了提升内存管理的效率，减少申请小内存造成的内存碎片问题， SGI STL 采用了两级配置器，当分配的空间大小超过 128byte 时，会使用第一级空间配置器；当分配的空间大小小于 128byte 时，将使用第二级空间配置器。第一级空间配置器直接使用 `malloc()`、`realloc()`、`free()` 函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存

## vector、list 的区别

`vector` 连续存储的容器，动态数组，在堆上分配空间，两倍容量增长，适用场景于经常随机访问，且不经常对非尾节点进行插入删除；扩容时一次性将数据拷贝至新空间

`list` 动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间，随机访问性能很差，只能快速访问头尾节点

## 迭代器

Iterator 模式又称 Cursor 模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示

迭代器不是指针，是类模板，表现的像指针，是一个可遍历STL 容器内全部或部分元素的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针

Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果

## sort

`sort()` 函数接受两个随机存取迭代器 [begin, end)

`map`、`set` 底层是 RB-tree，自动拥有排序功能；`stack`、`queue`、`priority_queue` 有特别的出入口，不允许排序；`list`、`slist` 迭代器是前进迭代器，不适用 `sort()`，但可以使用自身提供的成员函数 `sort()`

`sort()` 当数据量大时会采用快排，分段递归排序；一旦分段后的数据量小于某个阈值时，可以认为序列相对有序，改用插入排序效率更高；如果递归层次过深，还会改用堆排序

快排时采用三点中值作为中间点，所以也需要迭代器是个随机存取迭代器，这样才能获取排序序列的中央位置值

函数开始时，根据序列长度判断递归深度，用来控制分割恶化；判断序列长度是否大于 16，如果大于 16，再判断当前可继续递归层度，如果可继续递归层度为 0，则改用堆排序，否者再只对右半段进行快排，左半段不动；前面步骤全部结束后，序列相对有序，但未完全排序，最后再对整个序列进行插入排序

## STL 的 `resize()` 和 `reserve()` 

`resize()` 改变当前容器内含有元素的数量，`reserve()` 改变当前容器的最大容量

## vector 线程安全

STL 容器不是线程安全的

对于 `vector`，即使写方（生产者）是单线程写入，但是并发读的时候，由于潜在的内存重新申请和对象复制问题，会导致读方（消费者）的迭代器失效，甚至 core dump；如果是多个写方，并发的 `push_back()`，也会导致core dump

解决方案：

- 加锁：加锁是一种解决方案，但是 `std::mutex`互斥锁太重性能较差；对于多读少写的场景可以用读写锁 `std::shared_mutex`

- 固定 `vector` 大小，避免动态扩容；多线程不管是读还是写，都是通过容器的下标访问 `operator[]` 来访问元素，不要 `push_back()` 新元素；所谓的写操作在这里不是插入新元素，而是修改旧元素

- 当元素数量不好估计时使用环形队列

## C++ 中 struct 和 class

在 C++ 中，可以用 `struct` 和 `class` 定义类，都可以继承

区别在于：`struct` 的默认继承权限和默认访问权限是 `public`，而 `class` 的默认继承权限和默认访问权限是 `private`

## C++ 类中可以定义引用数据类型

C++ 类中可以定义引用数据类型，但必须通过构造函数初始化列表初始化

## 左值和右值

左值：能对表达式取地址或具名对象/变量。一般指表达式结束后依然存在的持久对象

右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象

右值引用实现了转移语义和精确传递，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；能够更简洁明确地定义泛型函数

## 源码到可执行文件过程

### 预编译

处理源码中 `#` 开头的预编译指令，生成 .ii 或 .i 文件

1. 删除所有的 `#define`，展开所有的宏定义

2. 处理所有的条件预编译指令

3. 处理 `#include` 预编译指令，将文件内容替换到它的位置

4. 删除所有的注释

5. 留所有的 `#pragma` 编译器指令

5. 添加行号和文件标识

### 编译

把预编译之后生成的 .i 或 .ii 文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的 .s 汇编代码文本文件

1. 词法分析

2. 语法分析

3. 语义分析

4. 优化

5. 目标代码生成

6. 目标代码优化

### 汇编

将汇编代码转变成机器可以执行的指令，根据汇编指令和机器指令的对照表一一翻译过来，产生 .o 或 .obj 目标文件

### 链接

链接本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接，从而形成一个可以执行的程序

链接分为静态链接和动态链接

#### 静态链接

在模块 main.c 中使用另一个模块 func.c 中的 `foo()` 函数；在 main.c 模块中每一处调用 `foo()` 时都必须确切知道 `foo()` 函数的地址；由于每个模块都是单独编译的，编译器在编译 main.c 的时候并不知道 `foo()` 函数的地址，所以编译器会暂时把这些调用 `foo()` 的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正

优点：静态链接使得进行模块化开发，大大提供了程序的开发效率；只需保证在开发者的计算机中有正确的 .lib 文件，在以二进制形式发布程序时不需考虑在用户的计算机上 .lib 文件是否存在及版本问题

缺点：浪费内存和磁盘空间（如果不同进程包含了相同的公用库，则内存中会存在两个副本）；模块更新困难

#### 动态链接

把链接过程推迟到运行时再进行

优点：解决了共享目标文件多个副本浪费磁盘和内存空间的问题；使开发过程中各个模块更加独立，耦合度变小；增加 CPU 缓存的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上

缺点：程序启动时发现 DLL 不存在，系统将终止程序并给出错误信息；减慢运行速度

## include

双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样

对于使用双引号包含的头文件，查找头文件路径的顺序为：当前头文件目录、编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

对于使用尖括号包含的头文件，查找头文件的路径顺序为：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径

## 内存泄漏

由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况

1. 堆内存泄漏：对内存指的是程序运行中根据需要分配通过 `malloc`、`realloc`、`new` 等从堆中分配的一块内存，而没有通过调用对应的 `free` 或者 `delete` 删掉

2. 系统资源泄露：程序使用系统分配的资源比如 Bitmap、handle、socket 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定

3. 没有将基类的析构函数定义为虚函数
