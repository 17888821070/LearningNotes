# 强制转换

C 风格的转换格式很简单，但是有不少缺点的：
1. 转换太过随意，可以在任意类型之间转换。你可以把一个指向 const 对象的指针转换成指向非 const 对象的指针，把一个指向基类对象的指针转换成一个派生类对象的指针，这些转换之间的差距是非常巨大的，但是传统的 C 语言风格的类型转换没有区分这些
2. C 风格的转换没有统一的关键字和标示符


## static_cast
```cpp
static_cast<type-id>(expression)
// 1. 执行非动态的转换操作，用于替代C中的转换操作
// 2. 替换隐式转换
```
- 用于类层次结构中基类和派生类之间指针或引用的转换；向上转换（派生类---->基类）是安全的；向下转换（基类---->派生类）由于没有动态类型检查，所以是不安全的
- 用于基本数据类型之间的转换，如把 `int` 转换为 `char`，这种带来安全性问题由程序员来保证
- 把空指针转换成目标类型的空指针
- 把任何类型的表达式转为 `void` 类型


## dynamic_cast
```cpp
dynamic_cast<type-id>(expression)
// 1. 基类必须要有虚函数，因为 dynamic_cast 是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中，只有一个类定义了虚函数，才会有虚函数表
// 2. 对于向下转换，dynamic_cast 是安全的（当类型不一致时，转换过来的是空指针），而 static_cast 是不安全的（当类型不一致时，转换过来的是错误意义的指针，可能造成踩内存，非法访问等各种问题）
// 3. dynamic_cast 还可以进行交叉转换
```
只有在派生类之间转换时才使用 `dynamic_cast`，`type-id` 必须是类指针，类引用或者 `void*`


## const_cast
```cpp
const_cast<type-id>(expression)
// 1. 唯一可以对常量进行操作的转换符
// 2. 去除常量性是一个危险的动作，尽量避免使用
```
- 常量指针转换为非常量指针，并且仍然指向原来的对象
- 常量引用被转换为非常量引用，并且仍然指向原来的对象


## reinterpret_cast
```cpp
reinterpret_cast<type-id>(expression)
// 1. 从底层对数据进行重新解释，依赖具体的平台，可移植性差
// 2. 可以将整型转换为指针，也可以把指针转换为数组
// 3. 可以在指针和引用里进行肆无忌惮的转换
```
不到万不得已，不用使用这个转换符，高危操作