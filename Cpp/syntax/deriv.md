# 类继承

 ## 公有派生（ is - a 关系）

```cpp
class derivedClass : public baseClass
{
};
```
使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问

派生类需要自己的构造函数：派生类可以根据需要添加额外的数据成员和成员函数，构造函数必须给新成员（如果有的话）和继承的成员提供数据

派生类构造函数必须使用基类的构造函数：创建派生类对象时，程序先创建基类对象，意味着基类对象应当在程序进入派生类构造函数之前被创建，使用初始化列表完成这一工作；如果不调用基类构造函数，程序将使用默认的基类构造函数，所以除非要使用默认构造函数，否则应显示调用正确的基类构造函数

释放对象顺序与创建顺序相反，即先释放派生类析构函数，再自动调用基类的析构函数

```cpp
derivedClass::derivedClass(int r, const string & str, const string & ln, bool ht) : baseClass(r, str, ln)
{
    rating = ht;
}
```

派生类对象可以使用基类的非私有方法

基类指针可以在不进行显式类型转换的情况下指向派生类的对象；基类引用可以在不进行显式类型转换的情况下引用派生类的对象；基类指针或引用只能用于调用基类的方法，不能调用派生类的方法。因此，将指向基类的指针或引用作为函数参数时，传入基类或派生类的指针或引用都可以

## 多态公有继承
```cpp
class baseClass
{
public:
    baseClass(){};
    virtual void func();
};

class derivedClass : public baseClass
{
public:
    derivedClass(){};
    virtual void func();
};
```
同一个方法在派生类和基类中的行为不同，成为多态

实现多态的两种机制：在派生类中重新定义基类的方法；使用 `virtual` 虚方法；使用指针或引用调用成员函数：

 - 如果没有 `virtual` 关键字，程序将根据引用类型或指针类型选择方法
 - 如果有 `virtual` 关键字，程序将根据引用或指针指向的对象的类型来选择方法（基类指针或引用可以指向派生类）

经常在基类中将派生类会重新定义的方法声明为虚方法；方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法，但最好也使用 `virtual` 关键字

基类声明一个虚析构函数，确保释放派生对象时，按正确的顺序调用析构函数；构造函数不能是虚函数；友元不能是虚函数，因为友元不是类成员，只有类成员才能使虚函数

重新定义继承的方法并不是重载，重新定义并不会生成函数的两个重载版本，无论参数列表是否相同，该操作将隐藏所有的同名基类方法

 

## 抽象基类
使用纯虚函数提供未实现的函数，`virtual type Func(int , double b) const = 0`

当类声明中包含纯虚函数时，则不能创建类的对象，只能用作基类，即抽象基类

派生类必须覆盖纯虚函数

## 私有继承
使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，意味着基类方法不会成为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用

私有继承是 has - a 关系的一部分；包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未命名的继承对象添加到类中

私有继承的派生类构造函数使用成员初始化列表

只能在派生类方法中使用基类方法，使用类名和作用域解析运算符来调用基类的方法

使用基类对象本身，为避免调用构造函数创建新的对象，可使用强制类型转换 this 指针来调用基类对象本身；同理，通过强制转换可以调用基类的友元函数

```cpp
cosnt string & Student::Name() const
{
    return (const string &) *this;
}
```

通常，应使用包含来建立 has - a 关系；如果新类需要访问原来类的保护成员，或需要重新定义虚函数，应使用私有继承


## 保护继承
使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员，
