# 异常

## throw

异常事件发生时，程序使用 `throw` 关键字抛出异常表达式

在包含了异常出现点的最内层的 `try` 块，依次按类型匹配 `catch` 语句中的异常对象

`throw` 语句必须包含在 `try` 块中，也可以是被包含在调用栈的外层函数的 `try` 块中

执行 `throw` 语句时，`throw` 表达式将作为对象被复制构造为一个新的对象，称为异常对象

异常对象放在内存的特殊位置，该位置既不是栈也不是堆

当执行一个 `throw` 语句时，跟在 `throw` 语句之后的语句将不再被执行，`throw` 语句的语法有点类似于 `return`，因此导致在调用栈上的函数可能提早退出

## 异常对象

异常对象是一种特殊的对象，编译器依据异常抛出表达式构造异常对象

异常对象可以进行复制构造，要求异常抛出表达式的复制构造函数（或移动构造函数）、析构函数不能是私有的

在 `throw` 语句中抛出局部变量的指针或引用也几乎是错误的行为

`throw` 表达式的静态编译类型将决定异常对象的类型，所以当 `throw` 出的是基类指针的解引用，而该指针所指向的实际对象是派生类对象，此时将发生派生类对象切割

## catch

如果 `catch` 语句的参数是引用类型，则该参数可直接作用于异常对象

如果 `catch` 参数是传值的，则复制构函数将依据异常对象来构造 `catch` 参数对象，在该 `catch` 语句结束的时候，先析构 `catch` 参数对象，然后再析构异常对象

在进行异常对象的匹配时，编译器不会做任何的隐式类型转换或类型提升

## exception

C++ `std::exception` 有一个 `what()` 虚函数，返回一个字符串

## 栈展开

异常抛出时，将一路向外层寻找 `catch` 语句

寻找结束于某个 `catch` 语句或标准库函数 `terminate`，在这个展开过程中局部变量的销毁问题很关键

```cpp
void test2() {
    string s("123456");
    char c = s.at(100);
    cout<<c;
}

void test1() {
    test2();
}

int main() {
    try {
        int * p = new int [100];
        test1();
        delete [] p;
    }
    catch(exception e) {
        cerr<<"error";
    }
    return 0;
}
```

可以使用 RAII 的思想管理资源，从而避免资源泄露

## 流程

发生异常时：

1. 首先检查异常发生的位置是否在当前函数的某个 `try` 中，如果在则寻找 `catch`，不在则沿着函数调用栈重复第一步

2. 找到对应的 `catch` 块，根据 RTTI 查看这个异常类型是否和 `catch` 块中捕获类型相同，不同则重复第一步，相同则继续

3. 处理异常，执行栈回退，释放 `try` 块中的局部变量

## 损耗

RTTI、不断的回溯会导致较多的 catch miss，从而导致性能损耗

## 异常机制与构造函数

构造函数没有返回值，所以应该使用异常机制来报告发生的问题

## 异常机制与析构函数

C++ 不禁止析构函数向外界抛出异常，但析构函数被期望不向外界函数抛出异常

析构函数中向函数外抛出异常，将直接调用 `terminator()` 系统函数终止程序

如果一个析构函数内部抛出了异常，就应该在析构函数的内部捕获并处理该异常，不能让异常被抛出析构函数之外