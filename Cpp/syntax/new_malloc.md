# 堆内存分配

|分配|释放|类型|能否重载|
|-|-|-|-|
`malloc()`|`free()`|C 函数|不能
`new`|`delete`|C++ 表达式|不能
`::operator new()`|`::operator delete()`|C++ 函数|能
`std::allocator<T>::allocate()`|`std::allocator<T>::deallocate()`|C++ 标准库|能

## new/delete

C++ 则提供了两个关键字 `new` 和 `delete`，需要编译器支持

使用 `new` 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算

`new` 做两件事，一是分配内存，二是调用类的构造函数；`delete` 会调用类的析构函数和释放内存；

`new` 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 `new` 是符合类型安全性的操作符

`new` 的底层其实就是 `malloc()`，`delete` 的底层其实就是 `free()`

## malloc/free

C 语言提供了 `malloc()` 和 `free()` 两个系统函数，完成对堆内存的申请和释放，`malloc()/free()` 是库函数，需要头文件支持

`malloc()` 需要显式地指出所需内存的尺寸

```cpp
    // 开辟单地址空间
    int *p = new int;  // 开辟大小为 sizeof(int) 空间
    int *q = new int(5);  // 开辟大小为 sizeof(int) 的空间，并初始化为 5
    
    // 开辟数组空间
    // 一维
    int *a = new int[100]{0};  // 开辟大小为 100 的整型数组空间，并初始化为 0
    // 二维
    int (*a)[6] = new int[5][6];
    // 三维
    int (*a)[5][6] = new int[3][5][6];
    // 四维及以上以此类推
    
    int (*p)[3] = (double(*)[3])malloc(sizeof(int) * 5 * 3);
```

`malloc` 和 `free` 只是分配和释放内存

`malloc` 内存分配成功则是返回 `void *`，需要通过强制类型转换将 `void*` 指针转换成我们需要的类型

## ::operator new/::operator delete

`::operator new` 和 `::operator delete` 底层也是 `malloc()` 和 `free()`

重载后可自定义该类的动态内存分配

```cpp
class A {
private:
    int a;

public:
    // 重载 ::operator new
    static void* operator new(size_t size) {

    }
    // 重载 ::operator new[]
    static void* operator new[](size_t size) {

    }

    // 重载 ::operator delete
    static void operator delete(void * pt) {

    }
    // 重载 ::operator delete[]
    static void operator delete[](void * pt) {

    }
}
```

## 深入 malloc()

### 内存池原理

glibc 库实现了 `malloc()`，它实现 linux 系统的堆管理，维护了多个不定长的内存块全局链表，每个链表负责一个大小范围，这种做法有效减少了分配大内存时的遍历开销，类似于哈希的方式，将很大的范围的数据散列到有限的几个小的范围内而不是所有数据都放在一起，虽然最终还是要在小的范围内查找，但是最起码省去了很多的开销，如果只有一个不定长链表那么就要全部遍历，如果分成 3 个，就省去了 2/3 的开销，总之这个策略十分类似于散列

glibc 另外的策略就是不止维护一类空闲链表，而是另外再维护一个缓冲链表和一个高速缓冲链表；在分配的时候首先在高速缓存中查找，失败之后再在空闲链表查找；如果找到的内存块比较大，那么将切割之后的剩余内存块插入到缓存链表；如果空闲链表查找失败那么就往缓存链表中查找，如果还是没有合适的空闲块，就向内存申请比请求数更大的内存块，然后把剩下的内存放入链表中

调用 `free()` 时，它将用户释放的内存块回收到空闲链表。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是， `malloc()` 请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块

### 内存分配原理

从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：`brk()` 和 `mmap()`

- `brk()` 是将数据段(.data)的最高地址指针 _edata 往高地址推

- `mmap()` 是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存

这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系

#### brk

`malloc` 小于 128KB 的内存，使用 `brk` 分配内存，将 _edata 往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)

#### mmap

`malloc` 大于 128KB 的内存，使用 `mmap` 分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)

#### 原因

因为只有一个 _edata 指针，所以 `brk` 分配的内存需要等到高地址内存释放以后才能释放（在高地址堆内存释放之前，低地址堆内存是不可能释放的，这就是内存碎片产生的原因），而 `mmap` 分配的内存可以单独释放

进程向 OS 申请和释放地址空间的接口 `sbrk`/`mmap`/`munmap` 都是系统调用，频繁调用系统调用都比较消耗系统资源的；缺页中断是内核行为，会导致内核态 CPU 消耗较大。另外，如果使用 `mmap` 分配小内存，会导致地址空间的分片更多，内核的管理负担更大

堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗

### malloc 头

`malloc()` 返回的地址前有一个 16 字节的地址头，用来表示分配的内存大小

前 8 个字节表示之前的空间有多少没有被分配的字节大小，后 8 个字节表示当前 `malloc()` 已经分配的字节大小，前 8 个字节通过加 1 来作为前一个数据块是否已经分配的标志，加1表示前一个数据块已经分配