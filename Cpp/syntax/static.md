# static

## 函数中的静态变量

当函数局部变量声明为 `static` 时，空间将在程序的生命周期内分配，即使多次调用该函数也只分配一次

```cpp
void func() {
    static int a = 0;
    cout<<a++<<endl;
}
int main() {
    for(int i = 0; i < 5; ++i) {
        func();
    }
    return 0;
}
// 0 1 2 3 4
```

## 全局静态变量

在全局变量之前加上关键字 `static`，全局变量就被定义成为一个全局静态变量，全局静态变量在声明他的文件之外是不可见的，准确地讲从定义之处开始到文件结尾

`static` 修饰的全局变量声明与定义同时进行

当在头文件定义全局静态变量时，多个文件 `include` 了该头文件后都会，预编译阶段会将头文件的定义拷贝至各个引用该头文件处，导致定义多个互相独立的静态变量，造成内存浪费

非 static 的全局变量默认是全局可见性的，而 static 的全局变量时局部文件可见，因此非 static 的同名全局变量会有链接错误，而 static 变量不会发生链接错误

## 类中的静态变量

由于声明为 `static` 的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量由对象共享，静态变量不能使用构造函数初始化

```cpp
class Apple 
{ 
public: 
    static int i; 

    Apple() 
    { 
        // Do nothing 
    }; 
}; 

int Apple::i = 1; 
```

静态数据成员初始化的格式如下：
`<数据类型> <类名>::<静态数据成员名> = <值>`

初始化在类体外进行，而前面不加 `static`，不能在类的头文件中；初始化时不加该成员的访问权限控制符 `private`，`public` 等；初始化时使用作用域运算符来标明它所属类，静态数据成员是类的成员，而不是对象的成员

## 普通静态函数

在函数的返回类型前加上关键字 `static`，函数就被定义成为普通静态函数，函数的定义和声明默认情况下是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用

## 静态成员函数

静态成员函数不能声明为 `const` 或 `volatile`，使用类名和范围解析运算符调用静态成员