# static

## 函数中的静态变量

当函数局部变量声明为 `static` 时，空间将在程序的生命周期内分配，即使多次调用该函数也只分配一次

```cpp
void func() {
    static int a = 0;
    cout<<a++<<endl;
}
int main() {
    for(int i = 0; i < 5; ++i) {
        func();
    }
    return 0;
}
// 0 1 2 3 4
```

## 全局静态变量

在全局变量之前加上关键字 `static`，全局变量就被定义成为一个全局静态变量，全局静态变量在声明他的文件之外是不可见的，准确地讲从定义之处开始到文件结尾

`static` 修饰的全局变量声明与定义同时进行

当在头文件定义全局静态变量时，多个文件 `include` 了该头文件后都会，预编译阶段会将头文件的定义拷贝至各个引用该头文件处，导致定义多个互相独立的静态变量，造成内存浪费

非 static 的全局变量默认是全局可见性的，而 static 的全局变量时局部文件可见，因此非 static 的同名全局变量会有链接错误，而 static 变量不会发生链接错误

## 类中的静态变量

由于声明为 `static` 的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量由对象共享，静态变量不能使用构造函数初始化

```cpp
class Apple 
{ 
public: 
    static int i; 

    Apple() 
    { 
        // Do nothing 
    }; 
}; 

int Apple::i = 1; 
```

静态数据成员初始化的格式如下：
`<数据类型> <类名>::<静态数据成员名> = <值>`

初始化在类体外进行，而前面不加 `static`，不能在类的头文件中；初始化时不加该成员的访问权限控制符 `private`，`public` 等；初始化时使用作用域运算符来标明它所属类，静态数据成员是类的成员，而不是对象的成员

## 普通静态函数

在函数的返回类型前加上关键字 `static`，函数就被定义成为普通静态函数，函数的定义和声明默认情况下是 `extern` 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用

## 静态成员函数

静态成员函数不能声明为 `const` 或 `volatile`，使用类名和范围解析运算符调用静态成员

## 静态变量初始化

C++ 标准规定：全局或静态对象当且仅当对象首次用到时才进行构造

全局变量、文件域的静态变量和类的静态成员变量在 `main` 执行之前的静态初始化过程中分配内存并初始化，局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化

对于出现在同一个编译单元内的全局变量来说，它们初始化的顺序与他们声明的顺序是一致的，销毁的顺序则反过来

静态变量的初始化分为两个过程，一个是静态初始化，一个是动态初始化

### 静态初始化过程

静态初始化在系统加载后执行第一条语句之前就已经完成，静态数据有两种：已初始化数据和未初始化数据。在映像文件里,它们分别被放入 data 段和 bss 段。只有 data 段的已初始化的数据才会真正被放入映像文件

```cpp
int a = 5;  // data 段 
int b;      // bss 段
```

对于有初始值的 data 中的数据，程序加载器会根据其大小在内存中分配空间，并根据映像文件里存储的初始值对变量做初始化

对于未初始化的 bss 中的数据，程序加载器会根据其大小在内存中分配空间，根据类型将变量初始化成默认初值

### 动态初始化过程

```cpp
Foo a;         // bss 段
Foo b = Foo(); // bss 段
```

静态对象被放在 bss 段，加载时首先被清零，然后程序在进入 `main` 函数之前，静态对象的构造函数会被调用，但跨编译单元的静态变量的初始化顺序是未定义的