# 线程安全

## 定义

一个线程安全的类：

- 多个线程同时访问时，表现出正确的行为

- 无论操作系统怎么调度线程，表现出正确的行为

- 调用端代码无需额外的同步或协调动作

## 指针问题根源

对于一个动态创建的对象，无法根据指针或引用判断对象的状态

## 构造函数线程安全

构造函数线程安全唯一要求：在构造期间不要暴露 `this` 指针，即：

- 不要在构造函数中注册回调

- 不在构造函数中把 `this` 跨线程传递

- 即便在构造函数最后一行代码（类可能作为基类进行构造）

构造函数执行期间对象还没有完成初始化，把 `this` 暴露给其他对象会使得其他对象访问到半成品

## 析构函数线程安全

使用互斥量 `mutex` 可以保证成员函数的线程安全，但在析构函数中因为析构函数会销毁 `mutex`，因此不能保证对象安全的析构

## 对成员函数使用互斥量可能引发死锁

```cpp
void swap (A & a, A & b) {
    lock_guard<mutex> lga(a.m_mutex);
    lock_guard<mutex> lgb(b.m_mutex);
    ...
}

A a, b;

// 可能引发死锁
// thread1
swap(a, b);
// thread2
swap(b, a);

// 同理，类中的 operator =(A&) 也会可能引发死锁
```

一个函数如果要锁住多个对象，为了保证按相同的顺序加锁，可以比较 `mutex` 对象的地址，始终先加锁地址较小的 `mutex`

## shared_ptr

`shared_ptr` 的引用计数 `++` 和 `--` 是线程安全的，但内部的两个指针的拷贝不是线程安全的，因此也会导致线程不安全

在多个线程同时访问一个 `shared_ptr` 时应该加锁

当 `shared_ptr` 作为函数参数时，会涉及到拷贝，因为拷贝的不安全需要加锁，导致拷贝开销比原始指针要高，所以当 `shared_ptr` 作为函数参数时尽量使用 `const ref` 进行传递


# 线程同步

## 四项原则

重要性从高到低排列：

- 尽量最低限度共享对象，减少需要同步的场合；如果要暴露，优先考虑只读对象；一定要修改对象，一定要做好同步措施

- 使用高级的并发编程构件，如 Task Queue、Producer-Consumer Queue 等

- 只用非递归的互斥量和条件变量，慎用读写锁，不要用信号量

- 只使用 `atomic<int>`

## mutex

原则：

- 使用 RAII 方法封装创建、加锁、销毁、解锁四个操作

- 只用非递归 `mutex`

- 不手动调用 `lock()` 和 `unlock()`，一切交给栈上的 `lock_guard` 或 `unique_guard`

- 注意调用栈上已持有的锁，防止因加锁顺序不同而造成死锁

