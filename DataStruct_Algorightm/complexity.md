# 复杂度

 ## 介绍

从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法

数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上

![](../Picture/DataStruct/complexity/01.jpg)

### 时间复杂度
假设每行代码执行的时间都一样为unit_time，所有代码的执行时间T(n)与每行代码的执行次数成正比

```cpp
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
// T(n) = (2n^2 + 2n + 3) * unit_time
// f(n) = 2n^2 + 2n + 3
// T(n) = O(n^2)
```
总结规律成一个公式：

![](../Picture/DataStruct/complexity/02.png)

其中，T(n)表示代码执行时间；n表示数据规模的大小；f(n)表示每行代码执行的次数综合；O表示代码执行时间T(n)与f(n)成正比
大O时间复杂度实际上并不是具体代码的真正执行时间，而表示代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度；
- 只关注循环执行次数最多的一段代码：我们通常忽略掉公式中的常量、低阶、系数，只记录一个最大量级就可以了
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
  
![](../Picture/DataStruct/complexity/03.jpg)

按照复杂度量级，可以粗略地分为两类，多项式量级和非多项式量级(O(n^2)和O(n!))；当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长

1. O(1） 常量级时间复杂度的一种表示方法，并不是指只执行一行代码；一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，时间复杂度也是 O(1)
2. O(logn)、O(nlogn)

```cpp
 i=1;
 while (i <= n)  {
   i = i * 3;
 }
// 时间复杂度就是 O(log2n)
```

在对数阶时间复杂度的表示方法里忽略对数的底，统一 O(logn)
O(nlogn) 循环 n 遍 O(logn) 就是 O(nlogn)

- 空间复杂度：全程渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系

- 最好、最坏时间复杂度：最好情况时间复杂度就是在最理想的情况下，执行代码的时间复杂度；最坏情况时间复杂度就是在最糟糕的情况下，执行代码的时间复杂度

```cpp
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
// 最好时间复杂度：O(1)
// 最坏时间复杂度：O(n)
```

- 平均时间复杂度

- 最好、最坏时间复杂度：最好理想的情况下执行代码的时间复杂度；最坏理想的情况下执行代码的时间复杂度

```cpp
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
// 最好时间复杂度 O(1)
// 最坏时间复杂度 O(n)
```

- 平均时间复杂度：最好、最坏时间复杂度都是极端情况下的代码复杂度，发生概率并不大；引入概率后，平均时间复杂度为加权平均时间复杂度

- 均摊时间复杂度