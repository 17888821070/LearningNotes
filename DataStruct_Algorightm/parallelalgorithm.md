# 并行算法

借助并行计算的处理思想对算法进行改造

## 并行排序

假设要给大小为 8GB 的数据进行排序，并且机器的内存可以一次性容纳这么多数据

- 归并排序并行化：将这 8GB 的数据划分成 16 个小的数据集合，每个集合包含 500MB 的数据；用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序；16 个小集合分别排序完成之后，再将这 16 个有序集合合并

- 快速排序并行化：扫描一遍数据，找到数据所处的范围区间；把这个区间从小到大划分成 16 个小区间，将 8GB 的数据划分到对应的区间中；针对这 16 个小区间的数据，启动 16 个线程并行地进行排序，排序结束后得到有序数据

这两种处理思路都是利用的都是分治的思想，对数据进行分片，然后并行处理

## 并行查找

将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1/k，然后我们针对这 k 个小数据集合分别构建哈希表，通过 16 个线程，并行地在这 16 个散列表中查找数据，这样的查找性能比起一个大散列表的做法，也并不会下降，反倒有可能提高

## 并行字符串匹配

把大的文本，分割成 16 个小文本，我们就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍

原本包含在大文本中的关键词，被一分为二，分割到两个小文本中，这就会导致尽管大文本中包含这个关键词，但在这 16 个小文本中查找不到它；只需要对每段的开头结尾做特殊处理即可

## 并行搜索

- 并行广度优先搜索：启动多个线程，并行地搜索下一层的顶点，利用两个队列来完成扩展顶点的工作；假设这两个队列分别是队列 A 和队列 B，多线程并行处理队列 A 中的顶点，并将扩展得到的顶点存储在队列 B 中。等队列 A 中的顶点都扩展完成之后，队列 A 被清空，我们再并行地扩展队列 B 中的顶点，并将扩展出来的顶点存储在队列 A；这样两个队列循环使用，就可以实现并行广度优先搜索算法