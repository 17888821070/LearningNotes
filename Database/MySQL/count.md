# count

在不同的 MySQL 引擎中，`count(*)` 有不同的实现方式

1. MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 `count(*)` 的时候会直接返回这个数，效率很高

2. InnoDB 执行 `count(*)` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数

InnoDB 中即使是在同一个时刻的多个查询，由于多版本并发控制 MVCC 的原因，InnoDB 表应该返回多少行也是不确定的

假设表 t 中现在有 10000 条记录，设计三个用户并行的会话：

- 会话 A 先启动事务并查询一次表的总行数

- 会话 B 启动事务，插入一行后记录后，查询表的总行数

- 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数

![](../../Picture/Database/MySQL/count/01.png)

因此对于 `count(*)` 请求来说，InnoDB 只能把数据一行一行地读出依次判断，可见的行才能够用于计算表的总行数

InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值，所以普通索引树比主键索引树小很多；对于 `count(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的，因此 MySQL 优化器会找到最小的那棵树来遍历

## 不同的 count 用法

`count()` 是一个聚合函数，对于返回的结果集，一行行地判断，如果 `count` 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值

对于 `count(主键 id)` 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加

对于 `count(1)` 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加

`count(1)` 执行得要比 `count(主键 id)` 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作


按照效率排序的话，`count(字段)` < `count(主键 id)` < `count(1)` ≈ `count(*)`，所以建议尽量使用 `count(*)`

