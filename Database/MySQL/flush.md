# 数据库抖动

InnoDB 在处理更新语句的时候，只做了写 redo log 一个磁盘操作，在更新内存写完 redo log 后，就返回给客户端，本次更新成功

把内存里的数据写入磁盘的过程称为 flush

当内存数据页跟磁盘数据页内容不一致的时候，称这个内存页为脏页；内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为干净页；不论是脏页还是干净页，都在内存中

- 当 InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写；checkpoint 推进需将对应的脏页 flush 进磁盘

![](../../Picture/Database/MySQL/flush/01.jpg)

- 当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用；如果淘汰的是脏页，就要先将脏页写到磁盘；如果脏页没刷，直接淘汰，虽然可以依靠 redo log 恢复到最新状态，但是 Redo Log 就成了唯一的依靠了，唯一的依靠就不能随便擦除，会制约 redo log 的擦除

- 系统要合理地安排时间，见缝插针地找时间，只要有机会就刷一点脏页

- MySQL 正常关闭，会把内存的脏页都 flush 到磁盘上，这样下次 MySQL 启动的时候，就可以直接从磁盘上读数据，启动速度会很快

## 对性能的影响

### 第一种情况

redo log 写满了，要 flush 脏页，这种情况是 InnoDB 要尽量避免的；整个系统就不能再接受更新了，所有的更新都必须堵住

日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的

### 第二种情况

内存不够用了，要先将脏页写到磁盘

InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：还没有使用的、使用了并且是干净页、使用了并且是脏页

InnoDB 的策略是尽量使用内存，因此对于一个长时间运行的库来说，未被使用的页面很少

当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页，这时候只能把最久不使用的数据页从内存中淘汰掉

如果要淘汰的是一个干净页，就直接释放出来复用

如果是脏页就必须先刷到磁盘，变成干净页后才能复用

一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长

## 刷脏页的控制策略

要正确地告诉 InnoDB 所在主机的 IO 能力，这样 InnoDB 才能知道需要全力刷脏页的时候，可以刷多快

在准备刷一个脏页的时候，如果这个数据页旁边的数据页刚好是脏页，就会把这个邻居也带着一起刷掉；而且这个把邻居拖下水的逻辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会被放到一起刷
