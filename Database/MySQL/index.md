# 索引

## 磁盘 IO 与索引

### 磁盘 IO

磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分

寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，旋转延迟就是 1 / 120 / 2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5 + 4.17 = 9ms左右

### 预读

当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内；当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到

每一次 IO 读取的数据我们称之为一页，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，B+ 树的一个节点存储在一页内

### 索引

添加索引使得每次查找数据时的磁盘 IO 次数控制在一个很小的数量级，最好是常数数量级

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息

索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录 ID 的辅助数据结构

DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度

优点：

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因

- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义

- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间

- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

缺点：

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加

- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间

原则：

- 在查询中很少使用或者参考的列不应该创建索引

- 只有很少数据值的列也不应该增加索引

- 定义为 text、image 和 bit 数据类型的列不应该增加索引

- 当修改性能远远大于检索性能时，不应该创建索引

- 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省索引空间

- 尽量的扩展索引，不要新建索引

- 定义有外键的数据列一定要建立索引

实现：一般分为 B+ 树索引和哈希索引

- B+ 树是非线性结构，它的节点是天然有序的；hash 桶是线性结构，哈希表中多个数据在存储关系上是没有任务顺序关系的

- 哈希索引适合等值查询，无法进行范围查询和模糊查询；B+ 树索引可以进行等值、部分前缀、范围查询

- B+ 树索引其非叶子节点均为 key 值，叶子节点是 key-data 键值对，叶子节点前后相连且有序

- 哈希索引 O(1) 在速度上毋庸置疑要快于 B+ 树近似 O(logn)，但哈希索引速度不稳定，当某个键值存在大量重复时效率极差

- 哈希索引无法利用索引完成排序

- 哈希索引不支持多列联合索引的最左匹配规则

- 哈希索引存储行指针，并通过开链的方式解决冲突

- 哈希索引没办法避免回表查询，B+ 树在聚簇索引和索引覆盖的情况下可以只通过索引查询

### 索引存储

数据库索引都是存储在磁盘上的，当数据量比较大的时候，索引也会很大；当我们利用索引查询的时候，不能把索引全部加载到内存，只能逐一加载每个磁盘页，磁盘页即对应着索引树的节点

磁盘 IO 次数由树的高度决定，因此不适合使用 BST 存储索引，因此需要使用更加矮胖的树结构

在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样

## AVL 树、RB 树、B 树和 B+ 树 

大多数自平衡搜索树（如 AVL 树和 RB 树）都会假定所有数据都在主内存中，但我们必须考虑无法容纳在主内存中的大量数据。当键的数量很大时，将以块形式从磁盘读取数据，与主存储器访问时间相比，磁盘访问时间非常高。

### AVL 树

自平衡二叉搜索树，树中任一节点的两个子树的高度差最大为 1，其查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(log n)

- 具有二叉查找树的特点(左子树任一节点小于父节点，右子树任一节点大于父节点)，任何一个节点的左子树与右子树都是平衡二叉树

- 任一节点的左右子树高度差小于 1

AVL 树通过旋转来调整平衡

### RB 树

AVL 树比红黑树更加平衡，但 AVL 树可能在插入和删除过程中引起更多旋转；如果频繁的插入和删除，应首选 RB 树；如果插入和删除操作的频率较低，而搜索操作的频率较高，则 AVL 树应优先于红黑树

### B 树

#### 定义

B 树叫平衡多路查找树，设计的主要思想是减少磁盘访问次数，大多数树操作(增、删、查、最大值、最小值等)都需要都需要 O(h) 磁盘访问，h 为树的高度。

通常，B 树节点的大小保持与磁盘块大小相等，由于 B 树的高度较低，因此与平衡的二叉搜索树（如AVL 树、RB 树等）相比，大多数操作的磁盘访问次数显著减少。

先定义一条数据记录为一个二元组 [key, data]，key 为记录的键值，对于不同数据记录，key 是互不相同的；data 为数据记录除 key 外的数据

- M 阶 B 树表示每个节点最多 M 个子树

- 每个非叶子节点由 n-1 个 key 和 n 个指针组成，其中 M/2 <= n <= M，其中 M/2 向上取整

- 每个叶子节点最少包含一个 key 和两个指针，最多包含 M-1 个 key 和 M 个指针，叶节点的指针均为 null

- 所有叶子节点都在同一层

- key 和指针互相间隔，节点两端是指针

- 一个节点中的 key 从左到右非递减排列

- 每个指针要么为 null，要么指向另外一个节点

- 如果某个指针在节点 node 最左边且不为 null，则其指向节点的所有 key 小于 v_key1，其中 v_key1 为 node 的第一个 key 的值

- 如果某个指针在节点 node 最右边且不为 null，则其指向节点的所有 key 大于 v_key2，其中 v_key2 为 node 的最后一个 key 的值

- 如果某个指针在节点 node 的左右相邻 key 分别是 key_i 和 key_i+1 且不为 null，则其指向节点的所有 key 小于 v_key_i+1 且大于 v_key_i

- 每个节点都存储数据

一颗 4 阶的 B 树，每个节点最多有 4 个子树、3 个 key，最少有 2 个子树、1 个 key

![d4zmE4.png](https://s1.ax1x.com/2020/08/27/d4zmE4.png)

#### 插入保持平衡

- 首先考虑要插入的子树是否已经超出了关键字数的限制

- 超出的话，如果要插入的位置是叶子节点，就只能拆一个关键字添加到要插入位置的父节点

- 如果非叶子节点，就得从其他子树拆子树给新插入的元素做孩子

#### 删除保持平衡

删除孩子后，父节点是否还满足子树 k 介于 M/2 和 M 的条件，不满足就得从别的节点拆子树甚至修改相关子树结构来保持平衡

#### 性质

由于 B-Tree 的特性，在 B-Tree 中按 key 检索数据流程：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败

B 树的树内存储数据，因此查询单条数据的时候，B 树的查询效率不固定，最好的情况是 O(1)，所以做单一数据查询的时候，使用 B 树平均性能更好，在特定数据重复多次查询的场景中更加高效

由于 B 树中各节点之间没有指针相邻，因此 B 树不适合做一些数据遍历操作

### B+ 树

与 B-Tree 相比，B+Tree 有以下不同点：

- n 个 key 对应 n 个指针 n 颗树，M/2 <= n <= M

- 非叶子节点不存储 data，只存储 key；叶子节点不存储指针

- 所有叶子节点增加了一个链指针

![d5S5Yd.png](https://s1.ax1x.com/2020/08/27/d5S5Yd.png)

B+ 树的数据只出现在叶子节点上，因此在查询单条数据的时候，查询速度非常稳定，所以在做单一数据的查询上，其平均性能并不如 B 树

B+ 树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得 B+ 树非常适合做范围查询

### 选择 B+ 树

- B 树只适合随机检索，而 B+ 树同时支持随机检索和顺序检索

- B+ 树空间利用率更高，可减少 IO 次数，磁盘读写代价更低：B+ 树内部结点比 B 树小，一次性读入内存中可以查找的关键字也就越多，从而 IO 次数降低了

- B+ 树的查询效率更加稳定

- 增删节点时，效率更高

## 索引类型

- 主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键

- 唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引

- 普通索引: 基本的索引类型，没有唯一性的限制，允许为 NULL 值

- 全文索引：基于相似度的查询，而不是原来的精确数值比较；`like + %` 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的；全文索引可能存在精度问题

## 聚簇索引和非聚簇索引

InnoDB 的 B+ Tree 可能存储的是整行数据，也有可能是主键的值

聚簇索引：在 InnoDB 里，索引 B+ Tree 的叶子节点存储了整行数据的是主键索引

非聚簇索引：索引 B+ Tree 的叶子节点存储了主键的值的是非主键索引

聚簇索引查询会更快，因为主键索引树的叶子节点直接就是我们要查询的整行数据了，而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值回表查询

## 非主键索引存储的是主键索引值

非主键索引直接存储数据的地址，会带来一些问题：

1. 数据库备份、迁移困难

2. 插入、删除数据时，B+ 树可能发生分裂，导致物理地址变化

3. 无法给物理地址加行级锁

## 覆盖索引

非主键索引并不一定都会回表查询

索引覆盖：当一个查询语句的执行只用从索引中就能够取得，则不必从数据表中读取

常见方法：对被查询的字段建立联合索引

## 联合索引和最左前缀匹配

### 联合索引

在创建多列索引时，根据业务需求，where 子句中使用最频繁的一列放在最左边，因为 MySQL 索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

当创建一个联合索引的时候，如 (key1,key2,key3)，相当于创建了 (key1)、(key1,key2) 和 (key1,key2,key3) 三个索引

= 和 in 可以乱序，查询优化器会帮你优化成索引可以识别的形式

### 最左前缀匹配

匹配时会一直向右匹配直到遇到范围查询，范围列可以用到索引，但是范围列后面的列无法用到索引，即索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引

like 语句中通配符出现在开头则不能使用索引

如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描

只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的

## 索引下推

使用联合索引时，索引下推优化可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

## 普通索引和唯一索引

当某个字段较大时，不适合做主键，会浪费大量磁盘空间，因此可以考虑在该字段设置唯一索引或普通索引

假设在 id 字段建立索引，执行 `select id from T where k=5`

### 查询区别

先通过 B+ 树从树根开始，按层搜索到叶子节点，找到相应的数据页，然后可以认为在数据页内部通过二分法来定位记录

- 对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录

- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索

这两个的不同带来的性能差距是微乎其微

InnoDB 的数据是按数据页为单位来读写的，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB

因为引擎是按页读写的，当找到第一个的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的查找和判断下一条记录的操作，就只需要一次指针寻找和一次计算

如果第一个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，但这种情况概率很低

### 更新过程

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作

change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge

除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge；在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作

将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升；数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，必须要将数据页读入内存才能判断；如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了

因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用

change buffer 用的是 buffer pool 里的内存，因此不能无限增大

因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大

对于更新的目标页在内存中：

- 对于唯一索引来说，判断到没有冲突，插入这个值，语句执行结束

- 对于普通索引来说，插入这个值，语句执行结束

此情况下，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间

对于更新的目标页不再内存中：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束

- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了

change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的

对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好

对于写完马上做查询的业务，即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程，这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价，change buffer 反而起到了副作用

## redo log 和 change buffer

change buffer 和 redo log 颗粒度不一样

change buffer 只是针对如果更改的数据所在页不在内存中才暂时储存在 change buffer 中

redo log 会记录一个事务内进行数据更改的所有操作，即使修改的数据已经在内存中了，那也会记录下来

redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写）

change buffer 主要节省的则是随机读磁盘的 IO 消耗

## 索引使用场景

- 查询时，加速 SQL 执行效率

- 如果没有创建索引，排序时将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），非常影响性能；建立索引后，数据本身有序，可直接按照索引的顺序和映射关系逐条取出数据

- 提高 join 效率

- 索引覆盖

## 索引失效

- 如果查询条件用 or，必须 or 条件中的每个列都加上索引，否则无效

- 违反最左匹配原则，则不适用索引

- like 语句中通配符出现在开头则不能使用索引

- 存在索引列的数据类型隐形转换，则不使用索引

- where 字句里对索引列有数学运算或者使用函数，则不使用索引

- mysql 优化器觉得全表扫描更快时，则不适用索引

## 自增主键

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护

- 页分裂：插入情况下，如果所在数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去；页分裂除了影响分类，还影响数据页利用率

- 页合并：当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并

自增主键是指自增列上定义的主键，在建表语句中一般这么定义 `NOT NULL PRIMARY KEY AUTO_INCREMENT`

插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值

每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，而业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小

从性能和存储空间方面考量，自增主键往往是更合理的选择