# 表数据

一个 InnoDB 表包含表结构定义和数据

每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中

一个表单独存储为一个文件更容易管理，在不需要这个表时通过 drop table 命令，系统就会直接删除这个文件

## 数据删除流程

删除某行数据时，InnoDB 引擎只会把记录标记为删除，之后要再插入一个记录时，可能会复用这个位置，磁盘文件的大小并不会因为删除而缩小

同理，删掉一个数据页上的所有记录，整个数据页都可以被复用

但是，数据页的复用跟记录的复用是不同的。记录的复用，只限于符合范围条件的数据，而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置

如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用

如果用 delete 命令把整个表的数据删除，所有的数据页都会被标记为可复用，但是磁盘上文件不会变小

不止是删除数据会造成空洞，插入数据也会；如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂

![](../../Picture/Database/MySQL/table/01.png)

更新索引上的值，可以理解为删除一个旧的值，再插入一个新值

## 重建表

经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的

可以使用 alter table A engine=InnoDB 命令来重建表，该命令执行流程为新建一个与表 A 结构相同的表 B，然后按照主键 ID 递增的顺序，把数据一行一行地从表 A 里读出来再插入到表 B 中；这个临时表 B 不需要手动创建，MySQL 会自动完成转存数据、交换表名、删除旧表的操作；数据搬运过程中，有新的数据要写入到表 A 的话，就会造成数据丢失

MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化

1. 建立一个临时文件，扫描表 A 主键的所有数据页

2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中

3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态

4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件

5. 用临时文件替换表 A 的数据文件

由于日志文件记录和重放操作这个功能的存在，这个方案在重建表的过程中，允许对表 A 做增删改操作