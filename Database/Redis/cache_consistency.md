# 缓存一致性

只要使用 Redis 缓存，就必然会面对缓存和数据库间的一致性保证问题

## 一致性

一致性情况包括：

- 缓存中有数据，缓存的数据值需要和数据库中的值相同

- 缓存中本身没有数据，数据库中的值必须是最新值

### 读写缓存

对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中

同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致

异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，数据库就没有最新的数据了

要想保证缓存和数据库中的数据一致，就要采用同步直写策略；但如果采用这种策略，就需要同时更新缓存和数据库；要在业务应用中使用事务机制，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试

对数据一致性的要求可能不是那么高，可以使用异步写回策略

### 只读缓存

对于只读缓存来说，如果有数据新增，会直接写入数据库；而有数据删改时，就需要把只读缓存中的数据标记为无效；后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了

新增数据，数据会直接写到数据库中，不用对缓存做任何操作；缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合一致性的第 2 种情况，所以，此时缓存和数据库的数据是一致的

删改数据既要更新数据库，也要在缓存中删除数据；在更新数据库和删除缓存值的过程中，无论这两个操作的执行顺序谁先谁后，只要有一个操作失败了，就会导致客户端读取到旧值，导致不满足缓存一致性

先删除缓存，再更新数据库，如果缓存删除成功，但是数据库更新失败，那么应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了

先完成了数据库的更新，但是在删除缓存时失败，那么数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时就会读到旧值了

[![rmtE60.png](https://s3.ax1x.com/2020/12/13/rmtE60.png)](https://imgchr.com/i/rmtE60)

[![rmUZoF.png](https://s3.ax1x.com/2020/12/13/rmUZoF.png)](https://imgchr.com/i/rmUZoF)

## 重试机制

可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中，当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新；如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作

## 高并发

即使更新数据库和删除缓存值成功，当有大量并发请求时，应用还是有可能读到不一致的数据

### 先删除缓存，再更新数据库

线程 A 删除缓存值后，还没有来得及更新数据库，线程 B 就开始读取数据；线程 B 会发现缓存缺失，就只能去数据库读取

导致线程 B 读取到了旧值，且会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值

等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了

[![rmNTGd.png](https://s3.ax1x.com/2020/12/13/rmNTGd.png)](https://imgchr.com/i/rmNTGd)

解决方案：在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作；线程 A sleep 的时间需要大于线程 B 读取数据再写入缓存的时间；其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值

这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做延迟双删

### 先更新数据库值，再删除缓存值

线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据；线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值

[![rmUiMq.png](https://s3.ax1x.com/2020/12/13/rmUiMq.png)](https://imgchr.com/i/rmUiMq)