# 数据结构

## 键值组织方式

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对

一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据；哈希桶中的元素保存的并不是值本身，而是指向具体值的指针；哈希桶中的 entry 元素中保存了 *key 和 *value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过 *value 指针被查找到

[![BIue8P.png](https://s1.ax1x.com/2020/11/07/BIue8P.png)](https://imgchr.com/i/BIue8P)

使用哈希表可以很快查找键值对，但哈希表的冲突问题和 rehash 可能带来的操作阻塞

### 哈希冲突

当往哈希表中写入更多数据时，哈希冲突是不可避免的问题，毕竟哈希桶的个数通常要少于 key 的数量，这也就是说，难免会有一些 key 的哈希值对应到了同一个哈希桶中

Redis 使用开链的方式解决哈希冲突，同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接

[![BIuDa9.png](https://s1.ax1x.com/2020/11/07/BIuDa9.png)](https://imgchr.com/i/BIuDa9)

### rehash

Redis 会对哈希表做 rehash 操作，rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突

为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间，随着数据逐步增多，Redis 开始执行 rehash

1. 给哈希表 2 分配更大的空间

2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中

3. 释放哈希表 1 的空间，留作下一次 rehash 扩容备用

第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求，所以 Redis 采用了渐进式 rehash

在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries；把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问

[![BIKomF.png](https://s1.ax1x.com/2020/11/07/BIKomF.png)](https://imgchr.com/i/BIKomF)


## 底层数据结构

Redis 的 value 支持的数据结构为：String、List、Hash、Set、Sorted Set

底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组

[![BImoeH.png](https://s1.ax1x.com/2020/11/07/BImoeH.png)](https://imgchr.com/i/BImoeH)

String 类型的底层实现只有一种数据结构，也就是简单动态字符串

List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构，这四种类型为集合类型，特点是一个键对应一个集合的数据

### 压缩链表

类似于一个数组，数组中的每一个元素都对应保存一个数据；和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束

[![BTXplt.png](https://s1.ax1x.com/2020/11/09/BTXplt.png)](https://imgchr.com/i/BTXplt)

在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了

|字段|长度|值
|-|-|-|
zlbytes|uint32_t|整个 ziplist 占用的内存字节数
zltail|uint32_t|起始位置与 ziplist 尾节点的偏移量
zllen|uint16_t|ziplist 中节点的数量，当这个值小于 UINT16_MAX （65535）时，这个值就是 ziplist 中节点的数量； 当这个值等于 UINT16_MAX 时，节点的数量需要遍历整个 ziplist 才能计算得出
zlend|uint8_t|255 的二进制值 1111 1111 （UINT8_MAX） ，用于标记 ziplist 的末端


### 跳表

在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位

[![BTv7yq.png](https://s1.ax1x.com/2020/11/09/BTv7yq.png)](https://imgchr.com/i/BTv7yq)