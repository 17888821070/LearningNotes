# IO 模型

Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程，但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的

## 多线程开销

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数

但是在采用多线程后，如果没有良好的系统设计，进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况

多线程编程模式面临的共享资源的并发访问控制问题，当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销

## 单线程 Redis 快

- 大部分操作在内存上完成

- 采用了高效的数据结构，如哈希表和跳表

- 采用了 IO 复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率

## 多路复用

Redis 网络框架调用 epoll 机制，让内核监听套接字，并且提供了基于事件的回调机制；select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件，事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理

## 潜在性能瓶颈

- 操作 bigkey：写入一个 bigkey 在分配内存时需要消耗更多的时间，同样删除 bigkey 释放内存同样会产生耗时

- 使用复杂度过高的命令

- Redis 的过期机制也是在主线程中执行的，大量 key 集中过期会导致处理一个请求时，耗时都在删除过期 key，耗时变长

- 淘汰策略也是在主线程执行的，当内存超过 Redis 内存上限后，每次写入都需要淘汰一些 key，也会造成耗时变长

- AOF 刷盘开启 always 机制

- 主从全量同步生成 RDB，虽然采用 fork 子进程生成数据快照，但 fork 这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久

- 并发量非常大时，单线程读写客户端 IO 数据存在性能瓶颈，虽然采用 IO 多路复用机制，但是读写客户端数据依旧是同步 IO，只能单线程依次读取客户端的数据，无法利用到 CPU 多核