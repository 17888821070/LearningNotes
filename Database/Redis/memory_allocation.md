# 内存分配策略

当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统，操作系统仍然会记录着给 Redis 分配了大量内存

虽然 Redis 管理了大量的内存，但由于内存不连续，这些不连续的内存空间很有可能处于一种闲置的状态，无法用来保存数据

## 内存碎片

虽然操作系统的剩余内存空间总量足够，但是应用申请的是一块连续地址空间的 N 字节，但在剩余的内存空间中，没有大小为 N 字节的连续空间了，这些剩余空间就是内存碎片

## 形成

内因是操作系统的内存分配机制，外因是 Redis 的负载特征

### 内存分配机制

内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配

jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间；将申请的内存分配给程序，将多的部分用链表保存，下次可以再分配给程序

### 负载特征

不同大小的键值对本身就会有大小不一的空间需求，容易造成碎片

## 指标

Redis 自身提供了 INFO 命令，可以用来查询内存使用的详细信息

有一个 mem_fragmentation_ratio 的指标，它表示的就是 Redis 当前的内存碎片率

mem_fragmentation_ratio = used_memory_rss/ used_memory，used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间

- mem_fragmentation_ratio 大于 1 但小于 1.5，这种情况是合理的

- mem_fragmentation_ratio 大于 1.5，表明内存碎片率已经超过了 50%

-  mem_fragmentation_ratio 小于 1，操作系统分配给 Redis 进程的物理内存要小于 Redis 实际存储数据的内存，也就是说 Redis 没有足够的物理内存可以使用了，导致 Redis 一部分内存数据会被换到 Swap 中，之后当 Redis 访问 Swap 中的数据时，延迟会变大，性能下降

## 措施

当 Redis 发生内存碎片后，一个简单粗暴的方法就是重启 Redis 实例，但容易发生数据丢失，又由于数据恢复，会有一段时间无法提供服务

Redis 自身提供了一种内存碎片自动清理的方法：当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统就会把数据拷贝到别处；数据拷贝需要能把这些数据原来占用的空间都空出来，把原本不连续的内存空间变成连续的空间

碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销；在数据拷贝时，Redis 无法及时处理请求，性能就会降低